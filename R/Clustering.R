
#' Identify clusters of pixels
#' 
#' Identify clusters of adjacent pixels of each type in a bad pixel map.
#' @param bpm Bad pixel map: a matrix or data frame containing coordinates of bad pixels and column "type" defining bad pixel type ("hot", "bright", "dim", "dead").
#' @return Data frame containing bad pixel coordinates and type, along with ID and size of cluster to which each is assigned.
#' @export
#' @examples
#' zz <- cluster.by.type(bpm)
#' 
cluster.by.type <- function(bpm) {
    
    # ensure that coordinates are unique
    bpm <- bpm[!duplicated(bpm[,1:2]),]
    
    # remove edge pixels from bad pixel map: redundant to cluster these
    px <- bpm[bpm$type != "edge",]
    
    # create matrix to populate raster
    px.vals <- array(dim = c(1996, 1996))
    px.vals[as.matrix(px[,1:2])] <- px$type
    
    # convert to raster
    r <- raster(t(px.vals[,1996:1]),  xmn = 0.5, xmx = 1996.5, ymn = 0.5, ymx = 1996.5)
    
    # cluster bad pixels by type
    xy <- data.frame()
    for (val in unique(getValues(r)[!is.na(getValues(r))])) {
        
        # mask all but one type of bad pixel
        tmp <- r; 
        tmp[tmp != val] <- NA
        
        # clump remaining bad pixels together
        cc <- clump(tmp, dir = 4)
        
        xy <- rbind(xy,
                    merge(data.frame(xyFromCell(cc, which(!is.na(getValues(cc)))),
                                     type = val,
                                     id = getValues(cc)[!is.na(getValues(cc))]),
                          setNames(data.frame(val, freq(cc)), c("type", "id", "count"))))
    }
    xy$type <- factor(levels(px$type)[xy$type], levels = levels(px$type))
    
    # rationalize cluster IDs (otherwise IDs are reused for each type)
    xy <- transform(xy, id = match(apply(xy[, c("type", "id")], 1, paste, collapse = "-"),
                                   unique(apply(xy[, c("type", "id")], 1, paste, collapse = "-"))))
    
    # recombine with excluded edge pixels to retain full bad pixel map
    if (nrow(px) != nrow(bpm)) {
        xy <- rbind(xy,
                    setNames(data.frame(bpm[bpm$type == "edge",], 
                                        "id" = max(xy$count) + 1,
                                        "count" = nrow(bpm[bpm$type != "edge",])),
                             c("x", "y", "type", "id", "count")))
    }
    
    # return data frame of pixel coords, pixel type, cluster size & id
    return(xy[,c("x", "y", "type", "id", "count")])
}


#' Enlarge screen spots to include any adjacent dim pixels
#' 
#' Extend any screen spots in an image to include any adjacent dim pixels detected.
#' @param bpm Bad pixel map with categories assigned to each pair of coordinates, as generated by \link{\code{bad.px}}
#' @return Updated ad pxiel map
#' @export
#' 
enhance.spots <- function(bpm) {
    
    # filter to retain only slightly dim pixels and identified screen spots
    px <- bpm[bpm$type %in% c("s.dim", "screen spot"),]
    
    # identify clusters of each type of bad pixel
    org.clumps <- cluster.by.type(px)
    
    # now need to identify clusters containing either/both types of bad pixel
    
    # create matrix to populate raster
    px.vals <- array(dim = c(1996, 1996))
    px.vals[as.matrix(px[,1:2])] <- 1
    
    # convert to raster
    r <- raster(t(px.vals[,1996:1]),  xmn = 0.5, xmx = 1996.5, ymn = 0.5, ymx = 1996.5)
    
    # clump pixels of both types together, get cluster sizes
    cc <- clump(r, dir = 4)
    new.clumps <- data.frame(xyFromCell(cc, which(!is.na(getValues(cc)))),
                             id = getValues(cc)[!is.na(getValues(cc))])
    new.clumps <- merge(new.clumps, count(new.clumps, "id"))
    
    matched <- merge(org.clumps[, c("x", "y", "type", "count")],
                     new.clumps[, c("x", "y", "freq", "id")])
    
    # assign a unique category to each new cluster identified
    # (if cluster contains screen spot, whole cluster becomes a screen spot)
    cat <- setNames(matched[order(matched$type), c("id", "type")], c("id", "new.type"))
    cat <- cat[!duplicated(cat$id),]
    
    # assign new category to each pixel
    matched <- merge(matched, cat)
    
    # recombine into complete bad pixel map
    if (nrow(px) != nrow(bpm)) {
        # rename columns in matched data to allow rbind
        df <- rbind(bpm[!bpm$type %in% c("s.dim", "screen spot"),],
                    setNames(matched[, c("x", "y", "new.type")], c("row", "col", "type")))
    }

    return(df)
}


#' Identify superclusters of pixels
#' 
#' Identify superclusters of bad pixels: small clusters of adjacent bad pixels of different types.
#' @param cl Bad pixel map or clustered bad pixel map: a matrix or data frame containing coordinates of bad pixels and column "type" defining bad pixel type, with cluster ID and count if already clustered by \link{\code{cluster.by.type}}
#' @param Vector of bad pixel types to exclude from superclusters. Default is to exclude screen spots, edge pixels and sightly bright pixels.
#' @details Only clusters of size 9 or less will be considered as part of a supercluster.
#' @return Data frame containing bad pixel coordinates and type, along with ID and size of clusters and superclusters to which each is assigned, and a shape classification based on these.
#' @export
#' @examples
#' # should both give same result
#' zz <- superclusters(cluster.by.type(bp))
#' zz <- superclusters(bp)
#' 
superclusters <- function(cl, excl = c("s.bright")) {
    
    # if data isn't already clustered, do so now
    if (is.null(cl$id) | is.null(cl$count)) {
        cl <- cluster.by.type(cl)
    }
    
    # exclude screen spots and any other categories to be excluded
    px <- cl[!(cl$type %in% c("screen spot", "edge", excl) | cl$count > 9),]
    
    # exclude clusters larger than 9 pixels: only interested in small clusters here
    # generally, removes areas of slightly dim pixels in corners/edges of image
    px <- px[px$count <= 9,]
    
    # create matrix to populate raster
    px.vals <- array(dim = c(1996, 1996))
    px.vals[as.matrix(px[,1:2])] <- px$type
    
    # convert to raster
    r <- raster(t(px.vals[,1996:1]),  xmn = 0.5, xmx = 1996.5, ymn = 0.5, ymx = 1996.5)
    
    # get clumps of pixels
    sc.cc <- clump(r, dir = 4)
    sc.xy <- merge(data.frame(xyFromCell(sc.cc, which(!is.na(getValues(sc.cc)))),
                              sc.id = getValues(sc.cc)[!is.na(getValues(sc.cc))]),
                   setNames(data.frame(freq(sc.cc)), c("sc.id", "sc.count")))
    
    # combine into single table of bad pixels with cluster & supercluster information
    xy <- merge(px, sc.xy, all = T)
    
    # assign supercluster classification to each pixel
    xy$sc.type <- factor("other", levels = c("singleton", "cluster", "supercluster", "other"))
    xy$sc.type[xy$count <= 9] <- "cluster"
    xy$sc.type[xy$count == 1] <- "singleton"
    xy$sc.type[xy$sc.count > xy$count] <- "supercluster"
    
    # recombine with previously excluded pixels to give complete bad pixel map
    if (nrow(cl) != nrow(px)) {
        xy <- rbind(xy,
                    cbind(cl[(cl$type %in% c("screen spot", "edge", excl) | cl$count > 9),],
                          sc.id = NA, sc.count = NA, sc.type = "other"))
    }

    # rationalise supercluster IDs
    xy[xy$sc.type != "supercluster", c("sc.id", "sc.count")] <- NA
    xy <- transform(xy, sc.id = match(sc.id, unique(sc.id)))
    
    return(xy)
}


#' Identify pixels with no x-ray response
#' 
#' Identify pixels whose behaviour in the grey or white images is the same as in the black images (no response to source)
#' @details Requires existence of \code{pw.m} in global environment.
#' @param dt String or integer date, format yymmdd.
#' @param limit Quantile of black pixel population to be used as cutoff.
#' @return Matrix of coordinates of non-responsive pixels
#' @export
#' @examples
#' qq <- no.response(160314, limit = 0.001)
no.response <- function(dt, limit = 0.01) {
    dt <- toString(dt)
    
    bn <- qJohnson(c(limit, 1-limit), JohnsonFit(pw.m[,,"black", dt]))
    
    un <- rbind(which(matrix(findInterval(pw.m[,,"grey", dt], bn), ncol = 1996) == 1, arr.ind = T),
                which(matrix(findInterval(pw.m[,,"white", dt], bn), ncol = 1996) == 1, arr.ind = T))
    return(un[!duplicated(un),])
}